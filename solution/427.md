# 427. 建立四叉树

[题目链接](https://leetcode.cn/problems/construct-quad-tree/description)

## 解法一：分治+递归

### 思路

- 递归的对象是网格的左上和右下坐标（只有一个网格包含在其中）
- 需要判断网格内是否值相等
  - 可以转化为求网格内的和
  - 0：说明均为0
  - 和网格面积相等：说明均为1

### 代码

```py
"""
# Definition for a QuadTree node.
class Node:
    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):
        self.val = val
        self.isLeaf = isLeaf
        self.topLeft = topLeft
        self.topRight = topRight
        self.bottomLeft = bottomLeft
        self.bottomRight = bottomRight
"""

class Solution:
    def construct(self, grid: List[List[int]]) -> 'Node':
        n = len(grid)
        s = [[0 for _ in range(n + 1)] for _ in range(n + 1)]

        for i in range(1, n + 1):
            for j in range(1, n + 1):
                s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + grid[i - 1][j - 1]

        def getSum(r0, c0, r1, c1):
            return s[r1][c1] - s[r0][c1] - s[r1][c0] + s[r0][c0]

        def dfs(r0, c0, r1, c1):
            cur_s = getSum(r0, c0, r1, c1)
            if cur_s == 0:
                return Node(False, True)
            elif cur_s == (r1 - r0) * (c1 - c0):
                return Node(True, True)

            return Node(
                True,
                False,
                dfs(r0, c0, (r0 + r1) // 2, (c0 + c1) // 2),
                dfs(r0, (c0 + c1) // 2, (r0 + r1) // 2, c1),
                dfs((r0 + r1) // 2, c0, r1, (c0 + c1) // 2),
                dfs((r0 + r1) // 2, (c0 + c1) // 2, r1, c1)
            )
            
        return dfs(0, 0, n, n)
```

### 复杂度

- 时间：O(n^2)
- 空间：O(n^2)
