# 1262. 可被三整除的最大和

[题目链接](https://leetcode.cn/problems/greatest-sum-divisible-by-three/description/)

## 解法一：动态规划

### 思路

- 状态机：考虑余数
  - f[i][j] 表示前 i 个数中 % 3 == j 的最大和
  - f[i][j] = max(f[i - 1][j], f[i - 1][(j - nums[i] % 3 + 3) % 3] + nums[i])
- 可以用滚动数组优化

### 代码

```py
class Solution:
    def maxSumDivThree(self, nums: List[int]) -> int:
        n = len(nums)

        f = [[-inf] * 3 for _ in range(2)]
        f[0][0] = 0

        for i in range(1, n + 1):
            num = nums[i - 1]
            for j in range(3):
                f[i % 2][j] = max(f[(i - 1) % 2][j], f[(i - 1) % 2][(j + 3 - (num % 3)) % 3] + num)

            # if num % 3 == 0:
            #     f[i][0] = f[i - 1][0] + num
            #     f[i][1] = f[i - 1][1] + num
            #     f[i][2] = f[i - 1][2] + num
            # elif num % 3 == 1:
            #     f[i][0] = max(f[i - 1][0], f[i - 1][2] + num)
            #     f[i][1] = max(f[i - 1][1], f[i - 1][0] + num)
            #     f[i][2] = max(f[i - 1][2], f[i - 1][1] + num)
            # elif num % 3 == 2:
            #     f[i][0] = max(f[i - 1][0], f[i - 1][1] + num)
            #     f[i][1] = max(f[i - 1][1], f[i - 1][2] + num)
            #     f[i][2] = max(f[i - 1][2], f[i - 1][0] + num)

        return f[n % 2][0]
```

### 复杂度

- 时间：O(nk)
- 空间：O(k)
