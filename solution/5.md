# 5. 最长回文子串

[题目链接](https://leetcode.cn/problems/longest-palindromic-substring/description/)

## 解法一：动态规划

### 思路

- 由于每个子串的中心是唯一的，所以可以直接枚举中心然后扩展

### 代码

```py
class Solution:
    def longestPalindrome(self, s: str) -> str:
        max_len = 0
        max_s_idx = None
        n = len(s)

        for i, c in enumerate(s):
            x = i - 1
            y = i + 1
            while x >= 0 and y < n and s[x] == s[y]:
                x -= 1
                y += 1
            if y - x - 1 > max_len:
                max_len = y - x - 1
                max_s_idx = x + 1

            x = i
            y = i + 1
            while x >= 0 and y < n and s[x] == s[y]:
                x -= 1
                y += 1
            if y - x - 1 > max_len:
                max_len = y - x - 1
                max_s_idx = x + 1

        return s[max_s_idx: max_s_idx + max_len]
```

### 复杂度

- 时间：O(n2)
- 空间：O(1)

### 代码优化

- 枚举中心时，可以跳过相同的部分
- 同时，相同的部分无需额外再次比较了，已经是回文，基于这部分向两侧扩展对比即可

```py
class Solution:
    def longestPalindrome(self, s: str) -> str:
        max_len = 0
        s_idx = None
        
        n = len(s)

        i = 0
        while i < n:
            l, r = i, i
            while r < n and s[r] == s[l]:
                r += 1

            i = r

            r -= 1
            while l >= 0 and r < n and s[l] == s[r]:
                l -= 1
                r += 1

            cur_len = r - l - 1
            if cur_len > max_len:
                max_len = cur_len
                s_idx = l + 1

        return s[s_idx: s_idx + max_len]
```

### 复杂度

- 时间：O(n^2)
- 空间：O(1)
