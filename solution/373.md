# 373. 查找和最小的 K 对数字

[题目链接](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/description)

## 解法一：堆

### 思路

- 由于数组有序，(i, j) 的下一个更大数对是 (i + 1, j) / (i, j + 1)
- 意味着 (i, j) 可以由 (i - 1, j) / (i, j - 1) 得到，会出现重复
- 一种做法是哈希表
- 还可以考虑规定 (i, j) 弹出后只加入 (i, j + 1)
  - 因为不考虑 i 的递增，所以初始化时，需要把所有 (i, 0) 加入堆

### 代码

```py
class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        ans = []

        n1 = len(nums1)
        n2 = len(nums2)

        h = [(nums1[i] + nums2[0], i, 0) for i in range(min(n1, k))]

        for _ in range(k):
            _, i1, i2 = heappop(h)
            ans.append([nums1[i1], nums2[i2]])
            if i2 + 1 < n2:
                heappush(h, (nums1[i1] + nums2[i2 + 1], i1, i2 + 1))

        return ans
```

### 复杂度

- 时间：O(klogmin(n, k))
- 空间：O(min(n, k))
