# 524. 通过删除字母匹配到字典里最长单词

[题目链接](https://leetcode.cn/problems/longest-word-in-dictionary-through-deleting/description/)

## 解法一：双指针

### 思路

- 注意仅仅是删除字母，仍然要保持顺序！所以不能直接对比字符出现的次数！
- 每次匹配 s 中靠前的字符即可

### 代码

```py
class Solution:
    def findLongestWord(self, s: str, dictionary: List[str]) -> str:
        res = ""
        for t in dictionary:
            i = j = 0
            while i < len(t) and j < len(s):
                if t[i] == s[j]:
                    i += 1
                j += 1
            if i == len(t):
                if len(t) > len(res) or (len(t) == len(res) and t < res):
                    res = t
        return res
```

### 复杂度

- 时间：O(n)
- 空间：O(1)

## 解法二：动态规划

### 思路

- 有大量遍历浪费在了寻找 s 中下一个和 t 匹配的字符上，考虑预处理
- f[i][j] 表示 s 中从位置 i 往后字符 j 第一次出现的位置
  - 如果 s[i] == j，那么 f[i][j] = i
  - 否则 f[i][j] = f[i + 1][j]
  - 从后往前遍历求解

### 代码

```py
class Solution:
    def findLongestWord(self, s: str, dictionary: List[str]) -> str:
        ans = ''

        n = len(s)

        f = [[0 for _ in range(26)] for _ in range(n + 1)]
        f[-1] = [n] * 26

        for i in range(n - 1, -1, -1):
            for j in range(26):
                if ord(s[i]) == j + ord('a'):
                    f[i][j] = i
                else:
                    f[i][j] = f[i + 1][j]

        for t in dictionary:
            valid = True
            i = 0
            for c in t:
                if f[i][ord(c) - ord('a')] == n:
                    valid = False
                    break
                else:
                    i = f[i][ord(c) - ord('a')] + 1
            
            if valid:
                if len(t) > len(ans) or len(t) == len(ans) and t < ans:
                    ans = t

        return ans
```

### 复杂度

- 时间：O(n + l)，l 为 dictionary 中字符串长度总和
- 空间：O(n)
