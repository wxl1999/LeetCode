# 313. 超级丑数

[题目链接](https://leetcode.cn/problems/super-ugly-number/description/)

## 解法一：动态规划

### 思路

- 当前丑数乘以质数就是下一个丑数的候选，其中最小的就是下一个
  - 小根堆维护所有候选的最小
  - 同时维护每个质数对应要去乘的丑数的索引
- 注意去重，只添加答案中没有的丑数

### 代码

```py
class Solution:
    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:
        dp = [1 for _ in range(n)]
        idx = 1
        h_list = [(primes[i], 0) for i in range(len(primes))]

        while idx < n:
            min_num, p_idx = heapq.heappop(h_list)
            if min_num != dp[idx - 1]:
                dp[idx] = min_num
                idx += 1

            p = min_num // dp[p_idx]
            p_idx += 1
            min_num = dp[p_idx] * p
            heapq.heappush(h_list, (min_num, p_idx))

        return dp[-1]
```

### 复杂度

- 时间：O(nlogk)
- 空间：O(k)
