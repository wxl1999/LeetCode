# 127. 单词接龙

[题目链接](https://leetcode.cn/problems/word-ladder/description)

## 解法一：BFS

### 思路

- 基本做法同 433
- 建图复杂度为 n^2，可以优化为 nk
  - 不遍历其余单词，直接将单词中的每一位修改为 *，将其与原单词连边
  - 等价于建立中间状态，如果两个单词只有一位不同，那么他们都会与这一位为 * 的单词有连边
  - 最终距离需要除2，由于是单词数目，还需要+1（边数+1=节点数）
- 需要加哈希表，防止环

### 代码

```py
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        word_set = set(wordList)
        if endWord not in word_set:
            return 0

        word_set.add(beginWord)
        
        word2id = dict()
        word_num = 0

        g = defaultdict(set)

        for word in word_set:
            if word not in word2id:
                word2id[word] = word_num
                word_num += 1
            word_idx = word2id[word]

            chars = list(word)
            for i, c in enumerate(chars):
                t = chars[i]

                chars[i] = '*'
                new_word = ''.join(chars)

                if new_word not in word2id:
                    word2id[new_word] = word_num
                    word_num += 1
                new_word_idx = word2id[new_word]
                
                g[word_idx].add(new_word_idx)
                g[new_word_idx].add(word_idx)

                chars[i] = t

        dis = [-1 for _ in range(word_num)]
        begin_id = word2id[beginWord]
        end_id = word2id[endWord]
        
        q = deque([begin_id])
        dis[begin_id] = 0
        
        while q:
            idx = q.popleft()
            if idx == end_id:
                return dis[end_id] // 2 + 1

            for nb in g[idx]:
                if dis[nb] == -1:
                    dis[nb] = dis[idx] + 1
                    q.append(nb)

        return 0
```

### 复杂度

- 时间：O(nk^2)
- 空间：O(nk^2)
