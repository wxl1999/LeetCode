# 背包

一般来说，答案是最后一个状态的值，所以可以从答案反推状态设计

## 01背包

[01背包](https://www.acwing.com/problem/content/2/)
[分割等和子集](../solution/416.md)
[目标和](../solution/494.md)

### 思路

- f[i][j]：前 i 个物品，容量上限为 j 的情况下的最大价值
  - f[N][V] 就是答案
- f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i])
  - 划分为是否包含第 i 个物品这两部分
  - 可以使用滚动数组优化

### 代码

[代码](https://www.acwing.com/solution/content/1374/)

## 完全背包

[完全背包](https://www.acwing.com/problem/content/3/)
[整数划分](https://www.acwing.com/problem/content/902/)
[完全平方数](../solution/279.md)
[零钱兑换](../solution/322.md)

### 思路

- f[i][j]：前 i 个物品，容量上限为 j 的情况下的最大价值
  - f[N][V] 就是答案
- f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i], f[i - 1][j - 2 * v[i]] + 2 * w[i], ...)
  - 划分为第 i 个物品用几个
  - 注意到 f[i][j - v[i]] = max(f[i - 1][j - v[i]], f[i - 1][j - 2 * v[i]] + w[i], f[i][j - 3 * v[i]] + 2 * w[i], ...)
  - 所以 f[i][j] = max(f[i - 1][j], f[i][j - v[i]] + w[i])
  - 可以使用滚动数组优化

# 线性DP

## 最长上升子序列

[题目链接](../solution/300.md)

## 最长公共子序列

[题目链接](../solution/1143.md)

## 最短编辑距离

[题目链接](../solution/72.md)

# 区间DP

## 戳气球

[题目链接](../solution/312.md)

